@namespace BlazorApp
@page "/dragdroptouch4"
@using System.Linq
@inject IJSRuntime JSRuntime

<Div Flex="Flex.Column" Width="Width.Is100">
    <Div Flex="Flex.Row" Width="Width.Is100">

        <Div Flex="Flex.Column" Width="Width.Is25"> 
            @foreach (var item in items)
            {
                <Button Clicked="@((args) => ItemSelected(args,@item))" draggable="false">
                    <Figure draggable="false">
                        <FigureImage Source="@item.Image" draggable="false" />
                        <FigureCaption>@item.Name</FigureCaption>
                    </Figure>
                </Button>
            }
        </Div>

        <div @ref="canvas" 
            style="min-width:1500px; touch-action: none; "
             >

            @foreach (var selectedItem in selectedItems)
            {
                <div
                    @onclick:preventDefault="true"
                    draggable="false"
                    @ref="selectedItem.Element"
                    @onpointerdown="@((args) => PointerDown(args,@selectedItem))"
                    @onpointermove="@((args) => PointerMove(args, @selectedItem))"
                    @onpointerup="@((args)=>PointerUp(args, @selectedItem))"

                    style="@selectedItem.Pos"
                    >
                    @*Note: The style assigned to the img prevents a serious bug in Blazor on iOS/Catalyst. Essentually, iOS trys to run some image processing 
                        on the img when it is clicked and a bug in that process causes the onpointermove to not fire. This style also addresses a "bug" in Andriod 
                        where the moveevents are doubled (causing the pointer to race ahead of the image movement). 
                    *@
                    <img
                        draggable="false"
                        src="@selectedItem.DropItem.Image"
                        class="figure-img img-fluid"
                        style="-webkit-touch-callout: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;" />
                </div>
            }
        </div>
    </Div>
    <p>ItemPointerCapture: @itemHasPointerCapture</p>
    <p>Start:@startMsg</p>
    <p>Move:@moveMsg</p>
    <p>End:@endMsg</p>
    <p>ItemPointerId: @itemPointerId</p>
</Div>


@code {
    private bool pointerDown = false;
    private ElementReference canvas;

    public class DropItem
    {
        public string Name { get; init; }
        public string Group { get; set; }
        public string Image { get; set; }
        public bool Fruit { get; set; }
    }
    public class SelectedItem
    {
        public DropItem DropItem { get; set; }
        public int X { get; set; } = 0;
        public int Y { get; set; } = 0;
        public int CursorXOffset { get; set; }
        public int CursorYOffset { get; set; }
        public int LastX { get; set; }
        public int LastY { get; set; }
        public string Pos => $"position:absolute; top:{Y}px; left:{X}px; width:48px; height:48px; z-index:10;";
        public ElementReference Element { get; set; }
    }
    private List<DropItem> items = new()
    {
        new DropItem() { Name = "Apple", Group = "Basket", Image = "_content/BlazorApp/img/apple.png", Fruit = true },
        new DropItem() { Name = "Bananas", Group = "Basket", Image = "_content/BlazorApp/img/bananas.png", Fruit = true },
    };
    private List<SelectedItem> selectedItems = new();
    private SelectedItem? selectedItem;
    private int lastTouchProcessed;
    private int pageX;
    private int pageY;
    private Boolean itemHasPointerCapture;
    private string startMsg = string.Empty;
    private string moveMsg = string.Empty;
    private string endMsg = string.Empty;
    private long itemPointerId;

    private Task ItemSelected(MouseEventArgs args, DropItem item)
    {
        selectedItems.Add(new SelectedItem()
            {
                DropItem = item,
                X = 150,
                Y = 150
            });
        return Task.CompletedTask;
    }

    private async void PointerDown(PointerEventArgs args, SelectedItem item)
    {
        itemPointerId = args.PointerId;

        if (pointerDown || item is null)
        {
            //Console.WriteLine("Pointerdown - item is null");
            return;
        }
        pageX = (int)args.PageX;
        pageY = (int)args.PageY;

        Console.WriteLine(startMsg = $"PointerDown x:{(int)args.ClientX} y:{(int)args.ClientY} xPage:{(int)args.PageX} yPage:{(int)args.PageY} xOffset:{(int)args.OffsetX} yOffset:{(int)args.OffsetY}");
        moveMsg = string.Empty;
        endMsg = string.Empty;
        pointerDown = true;
        selectedItem = item;

        await JSRuntime.InvokeVoidAsync("setPointerCapture", item.Element, args.PointerId);
        itemHasPointerCapture = await JSRuntime.InvokeAsync<Boolean>("hasPointerCapture", item.Element, args.PointerId);
        ;
    }

    private async void PointerMove(PointerEventArgs args, SelectedItem item)
    {
        if (!pointerDown)
        {
            Console.WriteLine($"PointerMove - !pointerDown");
            return;
        }

        if (selectedItem is null || selectedItem != item)
        {
            Console.WriteLine($"PointerMove - no selectedItem");
            return;
        }

        var movementX = (int)args.PageX - pageX;
        pageX = (int)args.PageX;
        selectedItem.X += movementX;
        var movementY = (int)args.PageY - pageY;
        pageY = (int)args.PageY;
        selectedItem.Y += movementY;

        itemHasPointerCapture = await JSRuntime.InvokeAsync<Boolean>("hasPointerCapture", selectedItem.Element, args.PointerId);

        Console.WriteLine(moveMsg = $"PointerMove x:{selectedItem.X} y:{selectedItem.Y} deltaX: {movementX} deltaY:{movementY}  pageX:{args.PageX} pageY:{args.PageY}");
    }


    private async void PointerUp(PointerEventArgs args, SelectedItem item)
    {
        if (selectedItem is null || selectedItem != item || !pointerDown)
            return;
        Console.WriteLine("PointerUp");
        var movementX = (int)args.PageX - pageX;
        pageX = (int)args.PageX;
        selectedItem.X += movementX;
        var movementY = (int)args.PageY - pageY;
        pageY = (int)args.PageY;
        selectedItem.Y += movementY;

        itemHasPointerCapture = await JSRuntime.InvokeAsync<Boolean>("hasPointerCapture", selectedItem.Element, args.PointerId);
        if(itemHasPointerCapture)
            await JSRuntime.InvokeVoidAsync("releasePointerCapture", selectedItem.Element, args.PointerId);
        itemHasPointerCapture = false;

        Console.WriteLine(endMsg = $"PointerUp x:{selectedItem.X} y:{selectedItem.Y} deltaX: {movementX} deltaY:{movementY}");
        pointerDown = false;
        selectedItem = null;

    }

}
